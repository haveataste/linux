ps命令
选项:
    a:显示现行终端机下的所有进程，包括其他用户的进程；
    u:显示进程拥有者、状态、资源占用等的详细信息（注意有“-”和无“-”的区别）；
    x:显示没有控制终端的进程。通常与 a 这个参数一起使用，可列出较完整信息；
    -e:显示所有进程；
    -f:完整输出显示进程之间的父子关系；
    -l:较长、较详细的将该 PID 的的信息列出；
    -o:自定义显示的字段；
请注意"ps -aux"不同于"ps aux"。POSIX和UNIX的标准要求"ps -aux"打印用户名为"x"的用户的所有进程，以及打印所有将由-a选项选择的过程。如果用户名为"x"不存在，ps的将会解释为"ps aux"，而且会打印一个警告。这种行为是为了帮助转换旧脚本和习惯。它是脆弱的，即将更改，因此不应依赖。
ps aux和ps -ef两者的输出结果差别不大，但展示风格不同。aux是BSD风格，-ef是System V风格。这是次要的区别，一个影响使用的区别是aux会截断command列，而-ef不会。当结合grep时这种区别会影响到结果。

kill命令
选项:
    -l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称
    -a  当处理当前进程时，不限制命令名和进程号的对应关系
    -p  指定kill命令只打印相关进程的进程号，而不发送任何信号
    -s  指定发送信号
    -u  指定用户
杀死指定用户所有进程
kill -9 $(ps -ef | grep user)

curl命令
curl -u "username":"password" -T upload-file webDAV_URL
curl -x, --proxy [protocol://]host[:port] Use this proxy
curl -x socks5://127.0.0.1:10808 -i http://icanhazip.com/
curl -L -o /tmp/go.sh https://install.direct/go.sh
curl -C, --continue-at <offset> Resumed transfer offset
curl -b, --cookie <data> Send cookies from string/file
curl -c, --cookie-jar <filename> Write cookies to <filename> after operation
curl -k, --insecure      Allow insecure server connections when using SSL
curl -f, --fail          Fail silently (no output at all) on HTTP errors
curl -s, --silent        Silent mode
curl -S, --show-error    Show error even when -s is used
curl -v, --verbose       Make the operation more talkative
curl --limit-rate 200k   Simulate speed limit
curl -G --data-urlencode 'key=value' URL
curl -A 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36'\
    -X POST\
    --data-urlencode 'url=http://vpnforgame.net/CN/?f=freevpn'\
    -d 'device=6'\
    -d 'flag=main'\
    -H 'Content-Type: application/x-www-form-urlencoded; charset=UTF-8'\
    -e https://www.page2images.com/\
    https://www.page2images.com/api/call
curl -A "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36"\
    -X POST\
    -d "flag=woplus&userMobile=1*********1"\
    -e "http://club.10155.com/h5/wojia/"\
    -H "Accept: application/json, text/plain, */*"\
    -H "Origin: http://club.10155.com"\
    http://club.10155.com/credit-mall/sms/getsmscode?flag=woplus

AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。
之所以叫 AWK 是因为其取自三位创始人 Alfred Aho，Peter Weinberger 和 Brian Kernighan 的 Family Name 的首字符。
awk -F: 'BEGIN{counter=0;}{counter++;print $1,"\t",$NF;}END{if(counter==NR)printf(counter);}' /etc/passwd
# 打印文件内容
awk '{print}' filename
awk '{print $0}' filename
awk '{print $1, $2}' filename
awk '{print $1 "\t" $2}' filename
awk '{print NR "\t" $1 "\t" $2}' filename   # NR number of record
awk '{print NF "\t" $0}' filename           # NF number of field
awk '$3==1986{print $0}' filename
awk '$1=="gold"{print $0}' filename
awk 'NR==7{print $0}' filename
# 默认输入、输出分隔符是空格，自定义分隔符如下
awk 'BEGIN{FS=","} {print $1, $2}'
awk 'BEGIN{0FS=","} {print $1, $2}'
awk '{print NR, FILENAME, $0}' file1 file2
# 打印每行的最后一列
awk '{print $NR}' filename
awk '{print $(NR-1)}' filename

# 文件添加扩展名
rename 's/$/\.txt/' *
# 文件名大写改小写
rename 'y/A-Z/a-z/' *
# 更改文件名样式，-v 选项会显示文件名改变的细节
rename -v 's/img_\d{3}(\d{4})\.jpeg/pic_$1.jpg/' *.jpeg

硬盘性能检测
dd if=/dev/zero of=tf bs=1M count=512 conv=fdatasync
echo 3 > /proc/sys/vm/drop_caches

df -h
lsblk命令 用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是它不会列出RAM盘的信息。块设备有硬盘，闪存盘，cd-ROM等等。lsblk命令包含在util-linux-ng包中，现在该包改名为util-linux。这个包带了几个其它工具，如dmesg。
$ lsblk -a           # 查看所有块设备
$ lsblk -b /dev/sda  # 查看指定设备的信息
NAME   MAJ:MIN RM         SIZE RO TYPE MOUNTPOINT
sda      8:0    0 240057409536  0 disk
├─sda1   8:1    0    536870912  0 part /boot/efi
├─sda2   8:2    0         1024  0 part
└─sda5   8:5    0 239517827072  0 part /
lsusb lscpu lsmem
dmesg | grep SATA
fdisk -l
hdparm -t /dev/sda
hdparm -T /dev/sda
yum install -y bonnie++ && bonnie -u root

tar命令
tar -zcvf fn.tar.gz file1 file2
tar -zxvf fn.tar.gz
tar -ztvf fn.tar.gz     # 列出压缩文件内容

zip file.zip *
  -r   recurse into directories
  -q   quiet operation
  -e   encrypt
unzip file.zip
  -t  test compressed archive data
  -v  list verbosely/show version info
分卷压缩解压
cat jdk* > all.zip
unzip -zvf all.zip

gzip命令
gzip file                # 压缩file，生成file.gz，并删除file
gzip -c file > file.gz   # 压缩file，但不删除file
gzip -d file.gz          # 解压并删除file.gz

du -sm * | sort -n | cat -n

export命令
用于设置或显示环境变量，仅限于该次登陆时有效。
选项:
    -f 　代表[变量名称]中为函数名称。
    -n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。
    -p 　列出所有的shell赋予程序的环境变量。
export FLASK_APP=hello.py

expr命令
expr 10 \* 10
expr length "abcdefg"

screen命令
-ls [match]   or
-list         Do nothing, just list our SockDir [on possible matches].
-S sockname   Name this session <pid>.sockname instead of <pid>.<tty>.<host>.
-r [session]  Reattach to a detached screen process.
-d (-r)       Detach the elsewhere running screen (and reattach here).
-wipe [match] Do nothing, just clean up SockDir [on possible matches].

查看Linux内核版本:
cat /proc/version
uname -a
查看Linux系统版本:
lsb_release -a
cat /etc/issue
cat /etc/redhat-release
查看Linux系统位数:
getconf LONG_BIT
查看CPU核数:
cat /proc/cpuinfo | grep name | cut -d: -f2 | uniq -c
    4  Intel(R) Core(TM) i5-4210M CPU @ 2.60GHz

# 源码安装linux软件
Linux上几乎所有的软件都经过了GPL授权，因此几乎所有的软件都会提供源码。而一个软件要在Linux上执行，必须是二进制文件，因此当我们拿到软件源码后，需要将它编译成二进制文件才能在Linux上运行。将源码编译成可供Linux运行的二进制文件一共需要两步：
1. 使用gcc编译器将源码编译成目标文件
2. 再次使用gcc编译器将目标文件链接成二进制文件
这过程看似简单，实则不然。一个软件的源代码往往被封装在多个源文件中，此外这些文件有错综复杂的依赖关系，编译需要严格按照指定的顺序进行，这无疑增加了编译的难度。好在make命令可以帮助我们简化编译过程。整个编译过程被浓缩在Makefile文件中(告诉make命令需要怎么去编译和链接程序)，当执行make命令时，make会去当前目录中寻找Makefile文件，并根据该文件中的要求完成整个编译过程。而Makefile文件由configure命令产生。当执行configure命令时，configure会根据当前系统环境动态生成一个适合本系统的Makefile文件，供make命令使用。
安装步骤：
1.cd /usr/local/ && mkdir memcached
2.wget http://memcached.org/files/memcached-1.4.29.tar.gz
3.tar -zxvf memcached-1.4.29.tar.gz                         # 解压源码，解压后查看INSTALL与README文件，这两个文件中详细介绍了本软件的安装方法和注意事项。
4../configure --prefix=/usr/local/memcached/                # 此时当前目录下将会生成一个Makefile文件。注意：–prefix参数指定软件安装目录。当执行make install命令时，会将软件安装在此路径中。
5.make uninstall && make clean                              # make clean命令用来清除上一次编译生成的目标文件。这个步骤可有可无，但为了确保编译的成功，还是加上为好。防止由于软件中含有残留的目标文件导致编译失败。
  make                                                      # 此时make会读取Makefile文件，将源码编译成二进制文件，并存放在当前目录下。
6.make install                                              # 此时二进制文件会被安装到先前configure prefix参数设置的路径中去。

# Debian Packager
dpkg -i visual_studio.deb
解决包依赖关系:
apt-get install -f
查看已经安装的软件:
dpkg -l
卸载软件:
dpkg -r google-chrome || dpkg -P google-chrome
查看deb包中的内容:
dpkg -c package.deb
列出deb包安装的所有文件清单:
dpkg -L package
从deb包中提取信息:
dpkg -I package.deb
显示已安装包的信息:
dpkg -s package
重新配制一个已经安装的包，如果它使用的是 debconf（debconf 为包安装提供了一个统一的配制界面）:
dpkg-reconfigure package

# Linux函数库
运行在Linux上的软件时常会调用Linux内核的某些功能或其他软件的某些功能，那么这些被软件调用的功能称为Linux的函数库。软件自身的函数库存放在软件安装目录下的lib中，而Linux的函数库存放在/usr/lib和/usr/include中，linux内核的函数库存放在/lib/modules中。
# Linux函数库的分类
1. 静态函数库
- 扩展名：xxx.a
- 在编译时会被整合到软件的二进制文件中去。因此拥有静态函数库的软件较为庞大。而且当系统的函数库更新时，引用该函数库的所有软件都需要重新编译才能正常使用。这是非常麻烦的！但拥有静态函数库的软件可以独立运行。
2. 动态函数库
- 扩展名：xxx.so
- 在编译时仅仅将函数库的路径整合到软件的二进制文件中去。由于软件中包含的是函数库的路径，因此该软件无法独立运行，且函数库的路径不能发生变化，一旦变化，该软件将无法找到函数库，从而无法运行！这是动态函数库的最大缺点。但当动态函数库更新时，软件无需重新编译，因此更新较为方便，这是动态函数库的最大优点。
目前大部分软件均使用动态函数库，就是因为动态函数库在更新时体现出的优势。
# 提升函数库读取效率
软件在运行某些功能时需要调用函数库中的函数，而函数库又是以文件的形式存放在外设上。那么如果将函数库存放在内存中，那么将会大大提升读取速度。在Linux中，可以使用ldconfig命令将指定的函数库加载进内存。具体步骤如下：
1. 在/etc/ld.so.conf中设置需要加载进内存的函数库
2. 使用ldconfig命令使配置生效
# 查看软件的动态函数库
ldd命令
在linux中，ldd是list dynamic dependencies的缩写，使用ldd命令即可查看指定软件所使用的全部动态函数库。
在实际linux开发与调试中，要经常查看动态库依赖关系，ldd用得还是比较多的，特别是出现故障的时候。
Q：error while loading shared libraries: libcares.so.2: cannot open shared object file: No such file or directory
A：sudo find / -name *libcares*
   如果找得到 libcares.so.2 这个,也就是和报错一模一样的名字的就说明本地有
   如果找不到, 可以试试 apt-get install libcares2 (apt install libc-ares2)
   如果 apt-get 失败, 就去 opensuse 下载:
   https://software.opensuse.org/download/package?package=libcares2&pro
   然后转换成 deb 包 alien libcares2_1.15.0+20200117-2.1_amd64.rpm
   最后 dkpg 安装 dpkg -i libcares2_1.15.0+20200117-2.1_amd64.deb
   如果还是报错, 就执行 ldconfig 命令重新链接一下
   尝试后还是报错的话就 cat /etc/ld.so.conf, 我的这个文件内容如下:
   include /etc/ld.so.conf.d/*.conf
   /usr/local/lib
   只需要将我的结果目录插入到这个 ld.so.conf 文件内就好:
   $ echo "/usr/lib64" >> /etc/ld.so.conf
   // 重新链接
   $ ldconfig
