DPI(Deep Packet Inspection)深度包检测技术是在传统IP数据包检测技术(OSI L2-L4之间包含的数据包元素的检测分析)之上增加了对应用层数据的应用协议识别，数据包内容检测与深度解码。

SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是"SOCKet Secure"的缩写。
当防火墙后的客户端要访问外部的服务器时，就跟SOCKS代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。
这个协议最初由David Koblas开发，而后由NEC的Ying-Da Lee将其扩展到SOCKS4。最新协议是SOCKS5，与前一版本相比，增加支持UDP、验证，以及IPv6。
根据OSI模型，SOCKS是会话层的协议，位于表示层与传输层之间。
SOCKS协议不提供加密。

SOCKS5 vs HTTP proxy
Unlike HTTP proxies, which can only interpret and work with HTTP and HTTPS webpages, SOCKS5 proxies can work with any traffic.
HTTP proxies are high-level proxies usually designed for a specific protocol. While this means you get better connection speeds, they’re not nearly as flexible and secure as SOCKS proxies.
SOCKS proxies are low-level proxies that can handle any program or protocol and any traffic without limitations.

PAC (proxy auto-config)
代理自动配置文件是一个 JavaScript 脚本，其核心是一个 JavaScript 函数，用来决定网页浏览请求（HTTP、HTTPS，和 FTP）应当直连目标地址，还是被转发给一个网页代理服务器并通过代理连接。PAC 文件中的核心 JavaScript 函数通常是这样定义的：
    function FindProxyForURL(url, host) {
      // ...
    }
参数
    url:要访问的 URL。URL 中类似 https:// 这样的的路径和查询组件已被去除。在 Chrome 浏览器（版本 52 至 73）中, 你可以通过设置 PacHttpsUrlStrippingEnabled 为 false 来禁止这种行为，或者以 --unsafe-pac-url 命令行参数启动（自 Chrome 74 起，仅命令行参数有效，且在 Chrome 75 及之后的版本中无法禁用这种行为；至于 Chrome 81，路径剥离对 HTTP URL 不适用，但有意改变这一行为以适应 HTTPS）；在 Firefox 浏览器中，对应的选项是 network.proxy.autoconfig_url.include_path。
    host:从 URL 中提取得到的主机名。这只是为了方便；它与 :// 之后到第一个 : 或 / 之前的字符串相同。端口号不包括在此参数中，必要时可以自行从 URL 中提取。
返回值
    FindProxyForURL() 函数返回一个描述了代理设置的字符串
    字符串中可以包含如下任意数量的“代理配置块”（building blocks），用分号分隔：
    DIRECT                   直连，不经过任何代理
    PROXY host:port          HTTP 代理
    SOCKS host:port          SOCKS 代理
    如果那个字符串为空，则不使用任何代理。

VMess 协议是由 V2Ray 原创并使用于 V2Ray 的加密传输协议，如同 Shadowsocks 一样为了对抗墙的深度包检测而研发的。在 V2Ray 上客户端与服务器的通信主要是通过 VMess 协议通信。
V2Ray 使用 inbound(传入) 和 outbound(传出) 的结构，这样的结构非常清晰地体现了数据包的流动方向，同时也使得 V2Ray 功能强大复杂的同时而不混乱，清晰明了。形象地说，我们可以把 V2Ray 当作一个盒子，这个盒子有入口和出口(即 inbound 和 outbound)，我们将数据包通过某个入口放进这个盒子里，然后这个盒子以某种机制（这个机制其实就是路由，后面会讲到）决定这个数据包从哪个出口吐出来。以这样的角度理解的话，V2Ray 做客户端，则 inbound 接收来自浏览器数据，由 outbound 发出去(通常是发到 V2Ray 服务器)；V2Ray 做服务器，则 inbound 接收来自 V2Ray 客户端的数据，由 outbound 发出去(通常是如 Google 等想要访问的目标网站)。
